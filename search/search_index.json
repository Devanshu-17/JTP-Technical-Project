{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Foodinator - A Food Recommendation System This is a food recommendation system that recommends food based on the user's preferences. The system uses a K-Means clustering algorithm to cluster similar foods together and recommend foods based on the user's preferences. It also supports direct food recommendation based on the user's food preferences by using cosine similarity. This project was developed as part of the Technical Project Round for JTP (Japan Third Party). Introduction One of the most challenging tasks for people is deciding what to eat. With so many food options available, it can be overwhelming to choose the right food that meets your preferences, allergens, and nutritional requirements. To address this issue, we have developed a food recommendation system called Foodinator. Overview Data Collection and Preprocessing The dataset used in the system has been created from scratch by using the Spoonacular API to fetch food items, their types, allergens, and nutritional information. The dataset has been cleaned and preprocessed to remove any missing values and outliers. Machine Learning Algorithms I have used various machine learning algorithms, such as K-Means clustering, Nearest Neighbors, Support Vector Machines, K-Nearest Neighbors and a Neural Network to cluster similar foods together and recommend foods based on the user's preferences. The K-Means clustering algorithm has been found to perform the best in terms of accuracy and efficiency. Features Feature 1: Recommends food based on the user's preferences. Feature 2: Provides detailed information about the recommended food items. Feature 3: Takes into account the user's allergens and nutritional requirements. Feature 4: Supports direct search functionality for food recommendation based on the user's food preferences. Technologies Used The system has been developed using the FastAPI framework for the backend and React for the frontend. The system uses MongoDB as the database to store the food items and user preferences. The system has been containerized using Docker to ensure easy deployment and scalability. Backend Frontend Database Containerization API Documentation The API documentation can be accessed by going to http://localhost:8000/docs .","title":"Home"},{"location":"#foodinator-a-food-recommendation-system","text":"This is a food recommendation system that recommends food based on the user's preferences. The system uses a K-Means clustering algorithm to cluster similar foods together and recommend foods based on the user's preferences. It also supports direct food recommendation based on the user's food preferences by using cosine similarity. This project was developed as part of the Technical Project Round for JTP (Japan Third Party).","title":"Foodinator - A Food Recommendation System"},{"location":"#introduction","text":"One of the most challenging tasks for people is deciding what to eat. With so many food options available, it can be overwhelming to choose the right food that meets your preferences, allergens, and nutritional requirements. To address this issue, we have developed a food recommendation system called Foodinator.","title":"Introduction"},{"location":"#overview","text":"","title":"Overview"},{"location":"#data-collection-and-preprocessing","text":"The dataset used in the system has been created from scratch by using the Spoonacular API to fetch food items, their types, allergens, and nutritional information. The dataset has been cleaned and preprocessed to remove any missing values and outliers.","title":"Data Collection and Preprocessing"},{"location":"#machine-learning-algorithms","text":"I have used various machine learning algorithms, such as K-Means clustering, Nearest Neighbors, Support Vector Machines, K-Nearest Neighbors and a Neural Network to cluster similar foods together and recommend foods based on the user's preferences. The K-Means clustering algorithm has been found to perform the best in terms of accuracy and efficiency.","title":"Machine Learning Algorithms"},{"location":"#features","text":"Feature 1: Recommends food based on the user's preferences. Feature 2: Provides detailed information about the recommended food items. Feature 3: Takes into account the user's allergens and nutritional requirements. Feature 4: Supports direct search functionality for food recommendation based on the user's food preferences.","title":"Features"},{"location":"#technologies-used","text":"The system has been developed using the FastAPI framework for the backend and React for the frontend. The system uses MongoDB as the database to store the food items and user preferences. The system has been containerized using Docker to ensure easy deployment and scalability.","title":"Technologies Used"},{"location":"#backend","text":"","title":"Backend"},{"location":"#frontend","text":"","title":"Frontend"},{"location":"#database","text":"","title":"Database"},{"location":"#containerization","text":"","title":"Containerization"},{"location":"#api-documentation","text":"The API documentation can be accessed by going to http://localhost:8000/docs .","title":"API Documentation"},{"location":"api_docs/","text":"API Docs Overview You can access the API documentation by running the application and visiting the /docs endpoint. The API documentation is generated using Swagger UI and provides a user-friendly interface to interact with the API. Visit the /docs endpoint in your browser to access the API documentation: http://localhost:8000/docs API Endpoints There are 3 main API endpoints in the Foodinator application: 1 . /recommend : This endpoint takes a user preferences as input and returns a list of recommended food items based on the input list. POST Request Body: { \"food_type\": \"string\", \"allergies\": [ \"string\" ], \"ingredients\": [ \"string\" ], \"calories\": 0, \"fat_content\": 0, \"protein_content\": 0, } Curl Request: curl -X 'POST' \\ 'http://localhost:8000/recommend/' \\ -H 'accept: application/json' \\ -H 'Content-Type: application/json' \\ -d '{ \"food_type\": \"Non-veg\", \"allergies\": [ \"None\" ], \"ingredients\": [ \"chicken\", \"salt\" ], \"calories\": 700, \"fat_content\": 20, \"protein_content\": 40 }' Response: [ { \"id\": 1, \"food\": \"string\" }, { \"id\": 2, \"food\": \"string\" }, { \"id\": 3, \"food\": \"string\" }, { \"id\": 4, \"food\": \"string\" }, { \"id\": 5, \"food\": \"string\" } ] 2 . /fetch-food-details : This endpoint takes a food item name as input and returns the details of the food item. GET Request: curl -X GET \"http://localhost:8000/fetch-food-details?food=string\" -H \"accept: application/json\" Response: { \"_id\": \"string\", \"id\": 0, \"food\": \"string\", \"image\": \"string\", \"instructions\": \"string\", \"food_type\": \"string\", \"Calories\": 0, \"FatContent\": 0, \"ProteinContent\": 0, \"glutenFree\": boolean, \"dairyFree\": boolean, \"sourceUrl\": \"string\", \"ingredients\": \"list of strings\" } 3 . /food_search : This endpoint takes a food item name as input and returns a list of food items that match the input name. POST Request: curl -X POST \"http://localhost:8000/food_search?food=string\" -H \"accept: application/json\" -d '' Response: [ { \"id\": 1, \"food\": \"string\" }, { \"id\": 2, \"food\": \"string\" }, { \"id\": 3, \"food\": \"string\" }, { \"id\": 4, \"food\": \"string\" }, { \"id\": 5, \"food\": \"string\" } ]","title":"API Docs"},{"location":"api_docs/#api-docs","text":"","title":"API Docs"},{"location":"api_docs/#overview","text":"You can access the API documentation by running the application and visiting the /docs endpoint. The API documentation is generated using Swagger UI and provides a user-friendly interface to interact with the API. Visit the /docs endpoint in your browser to access the API documentation: http://localhost:8000/docs","title":"Overview"},{"location":"api_docs/#api-endpoints","text":"There are 3 main API endpoints in the Foodinator application: 1 . /recommend : This endpoint takes a user preferences as input and returns a list of recommended food items based on the input list. POST Request Body: { \"food_type\": \"string\", \"allergies\": [ \"string\" ], \"ingredients\": [ \"string\" ], \"calories\": 0, \"fat_content\": 0, \"protein_content\": 0, } Curl Request: curl -X 'POST' \\ 'http://localhost:8000/recommend/' \\ -H 'accept: application/json' \\ -H 'Content-Type: application/json' \\ -d '{ \"food_type\": \"Non-veg\", \"allergies\": [ \"None\" ], \"ingredients\": [ \"chicken\", \"salt\" ], \"calories\": 700, \"fat_content\": 20, \"protein_content\": 40 }' Response: [ { \"id\": 1, \"food\": \"string\" }, { \"id\": 2, \"food\": \"string\" }, { \"id\": 3, \"food\": \"string\" }, { \"id\": 4, \"food\": \"string\" }, { \"id\": 5, \"food\": \"string\" } ] 2 . /fetch-food-details : This endpoint takes a food item name as input and returns the details of the food item. GET Request: curl -X GET \"http://localhost:8000/fetch-food-details?food=string\" -H \"accept: application/json\" Response: { \"_id\": \"string\", \"id\": 0, \"food\": \"string\", \"image\": \"string\", \"instructions\": \"string\", \"food_type\": \"string\", \"Calories\": 0, \"FatContent\": 0, \"ProteinContent\": 0, \"glutenFree\": boolean, \"dairyFree\": boolean, \"sourceUrl\": \"string\", \"ingredients\": \"list of strings\" } 3 . /food_search : This endpoint takes a food item name as input and returns a list of food items that match the input name. POST Request: curl -X POST \"http://localhost:8000/food_search?food=string\" -H \"accept: application/json\" -d '' Response: [ { \"id\": 1, \"food\": \"string\" }, { \"id\": 2, \"food\": \"string\" }, { \"id\": 3, \"food\": \"string\" }, { \"id\": 4, \"food\": \"string\" }, { \"id\": 5, \"food\": \"string\" } ]","title":"API Endpoints"},{"location":"installation/","text":"Getting Started Prerequisites Docker Install Docker by following the instructions here . Docker Compose Install Docker Compose by following the instructions here . Git Install Git by following the instructions here . Installation With Docker Clone the repository: git clone https://github.com/Devanshu-17/JTP-Technical-Project Navigate to the project directory: cd JTP-Technical-Project Run docker-compose up: docker-compose up --build Access the system Open your web browser and navigate to http://localhost:3000 to access the application. Backend: http://localhost:8000 Frontend: http://localhost:3000 Stop the system To stop the system, press Ctrl + C in the terminal and run the following command: docker-compose down Without Docker Clone the repository: git clone https://github.com/Devanshu-17/JTP-Technical-Project Navigate to the project directory: cd JTP-Technical-Project Install the required dependencies for the backend: Change the directory to the backend: cd backend Install the required dependencies: pip install -r requirements.txt Install the required dependencies for the frontend: Change the directory to the frontend: cd frontend Install the required dependencies: npm install Set up the MongoDB database. Install MongoDB by following the instructions here . Start the FastAPI development server: In the backend directory, run the following command: uvicorn app:app --reload In a separate terminal, start the React development server: In the frontend directory, run the following command: npm start Open your web browser and navigate to http://localhost:3000 to access the application.","title":"Installation"},{"location":"installation/#getting-started","text":"","title":"Getting Started"},{"location":"installation/#prerequisites","text":"Docker Install Docker by following the instructions here . Docker Compose Install Docker Compose by following the instructions here . Git Install Git by following the instructions here .","title":"Prerequisites"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#with-docker","text":"Clone the repository: git clone https://github.com/Devanshu-17/JTP-Technical-Project Navigate to the project directory: cd JTP-Technical-Project Run docker-compose up: docker-compose up --build Access the system Open your web browser and navigate to http://localhost:3000 to access the application. Backend: http://localhost:8000 Frontend: http://localhost:3000 Stop the system To stop the system, press Ctrl + C in the terminal and run the following command: docker-compose down","title":"With Docker"},{"location":"installation/#without-docker","text":"Clone the repository: git clone https://github.com/Devanshu-17/JTP-Technical-Project Navigate to the project directory: cd JTP-Technical-Project Install the required dependencies for the backend: Change the directory to the backend: cd backend Install the required dependencies: pip install -r requirements.txt Install the required dependencies for the frontend: Change the directory to the frontend: cd frontend Install the required dependencies: npm install Set up the MongoDB database. Install MongoDB by following the instructions here . Start the FastAPI development server: In the backend directory, run the following command: uvicorn app:app --reload In a separate terminal, start the React development server: In the frontend directory, run the following command: npm start Open your web browser and navigate to http://localhost:3000 to access the application.","title":"Without Docker"},{"location":"modules/","text":"Modules Overview app.py is the core script of the Foodinator application. This script initializes the FastAPI application, sets up the database connection, preprocesses the dataset, and defines the API endpoints for food recommendation and fetching food details. database.py provides functions for interacting with MongoDB. It includes functions to save the dataset to MongoDB and fetch food data from MongoDB. 1. database.py This module provides functions for interacting with MongoDB. save_dataset_to_mongodb def save_dataset_to_mongodb(data_file, mongodb_url, mongodb_database, mongodb_collection): \"\"\" Saves a dataset to MongoDB. Args: data_file (str): Path to the dataset file. mongodb_url (str): URL of the MongoDB server. mongodb_database (str): Name of the MongoDB database. mongodb_collection (str): Name of the MongoDB collection. Returns: None \"\"\" This function saves the dataset to MongoDB. It takes the path to the dataset file, MongoDB URL, database name, and collection name as input. #Example: save_dataset_to_mongodb(\"food_dataset.csv\", \"mongodb://localhost:27017\", \"food_database\", \"food_collection\") fetch_food_data_from_mongodb def fetch_food_data_from_mongodb(food_name, mongodb_url, mongodb_database, mongodb_collection): \"\"\" Fetches food data from MongoDB based on the food name. Args: food_name (str): Name of the food item. mongodb_url (str): URL of the MongoDB server. mongodb_database (str): Name of the MongoDB database. mongodb_collection (str): Name of the MongoDB collection. Returns: dict: Food details retrieved from MongoDB. \"\"\" This function fetches food data from MongoDB based on the food name. It takes the food name, MongoDB URL, database name, and collection name as input. And return the food details as a dictionary. # Example: fetch_food_data_from_mongodb(\"Pizza\", \"mongodb://localhost:27017\", \"food_database\", \"food_collection\") 2. app.py This module defines the FastAPI application and its endpoints. preprocess_input def preprocess_input(food_type, calories, fat_content, protein_content, gluten_free, dairy_free): \"\"\" Preprocesses input criteria for recommending food items. Args: food_type (str): Type of food item. calories (int): Number of calories. fat_content (int): Amount of fat in grams. protein_content (int): Amount of protein in grams. gluten_free (bool): Whether the food item is gluten-free. dairy_free (bool): Whether the food item is dairy-free. Returns: str: Preprocessed input string. \"\"\" This function preprocesses the input criteria for recommending food items. It takes the food type, calories, fat content, protein content, gluten-free status, and dairy-free status as input. # Example: preprocess_input(\"Pizza\", 300, 15, 10, True, False) And return the preprocessed input string. find_cluster def find_cluster(input_string, vectorizer, kmeans): \"\"\" Finds the cluster number based on input criteria. Args: input_string (str): Preprocessed input string. vectorizer (TfidfVectorizer): Fitted TfidfVectorizer object. kmeans (KMeans): Fitted KMeans object. Returns: int: Cluster number. \"\"\" This function finds the cluster number based on the input criteria. It takes the preprocessed input string, fitted TfidfVectorizer object, and fitted KMeans object as input. # Example: find_cluster(\"Pizza 300 15 10 True False\", vectorizer, kmeans) And return the cluster number. recommend_food_by_cluster def recommend_food_by_cluster(df, cluster, num_recommendations=5): \"\"\" Recommends food items from the same cluster Args: df (pd.DataFrame): DataFrame containing food items cluster (int): Cluster number num_recommendations (int): Number of recommendations to return Returns: pd.DataFrame: Recommended food items \"\"\" This function recommends food items from the same cluster. It takes the DataFrame containing food items, cluster number, and number of recommendations as input. # Example: recommend_food_by_cluster(df, 0, 5) And return the recommended food items. recommend_food def recommend_food(df, vectorizer, kmeans, food_type, calories, fat_content, protein_content, gluten_free, dairy_free, ingredients, num_recommendations=5): \"\"\" Recommends food items based on user input Args: df (pd.DataFrame): DataFrame containing food items vectorizer (TfidfVectorizer): Fitted TfidfVectorizer object kmeans (KMeans): Fitted KMeans object food_type (str): Type of food item calories (int): Number of calories fat_content (int): Amount of fat in grams protein_content (int): Amount of protein in grams gluten_free (bool): Whether the food item is gluten-free dairy_free (bool): Whether the food item is dairy-free ingredients (list): List of ingredients to filter by num_recommendations (int): Number of recommendations to return Returns: pd.DataFrame: Recommended food items \"\"\" This function recommends food items based on user input. It takes the DataFrame containing food items, fitted TfidfVectorizer object, fitted KMeans object, food type, calories, fat content, protein content, gluten-free status, dairy-free status, ingredients, and number of recommendations as input. # Example: recommend_food(df, vectorizer, kmeans, \"Pizza\", 300, 15, 10, True, False, [\"cheese\", \"tomato\"], 5) And return the recommended food items. request_body # Define request body model class UserInput(BaseModel): \"\"\" Request body for recommending food items \"\"\" food_type: str allergies: list ingredients: list calories: int = None fat_content: int = None protein_content: int = None This class defines the request body model for recommending food items. It includes the food type, allergies, ingredients, calories, fat content, and protein content. recommend_food_by_search def recommend_food_by_search(food_name, df, cosine_sim): \"\"\" Recommends food items based on a search query Args: food_name (str): Food item to search for df (pd.DataFrame): DataFrame containing food items cosine_sim (np.array): Cosine similarity matrix Returns: list: Top 5 recommended food items \"\"\" This function recommends food items based on a search query. It takes the food name, DataFrame containing food items, and cosine similarity matrix as input. # Example: recommend_food_by_search(\"Pizza\", df, cosine_sim) And return the top 5 recommended food items.","title":"Modules"},{"location":"modules/#modules","text":"","title":"Modules"},{"location":"modules/#overview","text":"app.py is the core script of the Foodinator application. This script initializes the FastAPI application, sets up the database connection, preprocesses the dataset, and defines the API endpoints for food recommendation and fetching food details. database.py provides functions for interacting with MongoDB. It includes functions to save the dataset to MongoDB and fetch food data from MongoDB.","title":"Overview"},{"location":"modules/#1-databasepy","text":"This module provides functions for interacting with MongoDB.","title":"1. database.py"},{"location":"modules/#save_dataset_to_mongodb","text":"def save_dataset_to_mongodb(data_file, mongodb_url, mongodb_database, mongodb_collection): \"\"\" Saves a dataset to MongoDB. Args: data_file (str): Path to the dataset file. mongodb_url (str): URL of the MongoDB server. mongodb_database (str): Name of the MongoDB database. mongodb_collection (str): Name of the MongoDB collection. Returns: None \"\"\" This function saves the dataset to MongoDB. It takes the path to the dataset file, MongoDB URL, database name, and collection name as input. #Example: save_dataset_to_mongodb(\"food_dataset.csv\", \"mongodb://localhost:27017\", \"food_database\", \"food_collection\")","title":"save_dataset_to_mongodb"},{"location":"modules/#fetch_food_data_from_mongodb","text":"def fetch_food_data_from_mongodb(food_name, mongodb_url, mongodb_database, mongodb_collection): \"\"\" Fetches food data from MongoDB based on the food name. Args: food_name (str): Name of the food item. mongodb_url (str): URL of the MongoDB server. mongodb_database (str): Name of the MongoDB database. mongodb_collection (str): Name of the MongoDB collection. Returns: dict: Food details retrieved from MongoDB. \"\"\" This function fetches food data from MongoDB based on the food name. It takes the food name, MongoDB URL, database name, and collection name as input. And return the food details as a dictionary. # Example: fetch_food_data_from_mongodb(\"Pizza\", \"mongodb://localhost:27017\", \"food_database\", \"food_collection\")","title":"fetch_food_data_from_mongodb"},{"location":"modules/#2-apppy","text":"This module defines the FastAPI application and its endpoints.","title":"2. app.py"},{"location":"modules/#preprocess_input","text":"def preprocess_input(food_type, calories, fat_content, protein_content, gluten_free, dairy_free): \"\"\" Preprocesses input criteria for recommending food items. Args: food_type (str): Type of food item. calories (int): Number of calories. fat_content (int): Amount of fat in grams. protein_content (int): Amount of protein in grams. gluten_free (bool): Whether the food item is gluten-free. dairy_free (bool): Whether the food item is dairy-free. Returns: str: Preprocessed input string. \"\"\" This function preprocesses the input criteria for recommending food items. It takes the food type, calories, fat content, protein content, gluten-free status, and dairy-free status as input. # Example: preprocess_input(\"Pizza\", 300, 15, 10, True, False) And return the preprocessed input string.","title":"preprocess_input"},{"location":"modules/#find_cluster","text":"def find_cluster(input_string, vectorizer, kmeans): \"\"\" Finds the cluster number based on input criteria. Args: input_string (str): Preprocessed input string. vectorizer (TfidfVectorizer): Fitted TfidfVectorizer object. kmeans (KMeans): Fitted KMeans object. Returns: int: Cluster number. \"\"\" This function finds the cluster number based on the input criteria. It takes the preprocessed input string, fitted TfidfVectorizer object, and fitted KMeans object as input. # Example: find_cluster(\"Pizza 300 15 10 True False\", vectorizer, kmeans) And return the cluster number.","title":"find_cluster"},{"location":"modules/#recommend_food_by_cluster","text":"def recommend_food_by_cluster(df, cluster, num_recommendations=5): \"\"\" Recommends food items from the same cluster Args: df (pd.DataFrame): DataFrame containing food items cluster (int): Cluster number num_recommendations (int): Number of recommendations to return Returns: pd.DataFrame: Recommended food items \"\"\" This function recommends food items from the same cluster. It takes the DataFrame containing food items, cluster number, and number of recommendations as input. # Example: recommend_food_by_cluster(df, 0, 5) And return the recommended food items.","title":"recommend_food_by_cluster"},{"location":"modules/#recommend_food","text":"def recommend_food(df, vectorizer, kmeans, food_type, calories, fat_content, protein_content, gluten_free, dairy_free, ingredients, num_recommendations=5): \"\"\" Recommends food items based on user input Args: df (pd.DataFrame): DataFrame containing food items vectorizer (TfidfVectorizer): Fitted TfidfVectorizer object kmeans (KMeans): Fitted KMeans object food_type (str): Type of food item calories (int): Number of calories fat_content (int): Amount of fat in grams protein_content (int): Amount of protein in grams gluten_free (bool): Whether the food item is gluten-free dairy_free (bool): Whether the food item is dairy-free ingredients (list): List of ingredients to filter by num_recommendations (int): Number of recommendations to return Returns: pd.DataFrame: Recommended food items \"\"\" This function recommends food items based on user input. It takes the DataFrame containing food items, fitted TfidfVectorizer object, fitted KMeans object, food type, calories, fat content, protein content, gluten-free status, dairy-free status, ingredients, and number of recommendations as input. # Example: recommend_food(df, vectorizer, kmeans, \"Pizza\", 300, 15, 10, True, False, [\"cheese\", \"tomato\"], 5) And return the recommended food items.","title":"recommend_food"},{"location":"modules/#request_body","text":"# Define request body model class UserInput(BaseModel): \"\"\" Request body for recommending food items \"\"\" food_type: str allergies: list ingredients: list calories: int = None fat_content: int = None protein_content: int = None This class defines the request body model for recommending food items. It includes the food type, allergies, ingredients, calories, fat content, and protein content.","title":"request_body"},{"location":"modules/#recommend_food_by_search","text":"def recommend_food_by_search(food_name, df, cosine_sim): \"\"\" Recommends food items based on a search query Args: food_name (str): Food item to search for df (pd.DataFrame): DataFrame containing food items cosine_sim (np.array): Cosine similarity matrix Returns: list: Top 5 recommended food items \"\"\" This function recommends food items based on a search query. It takes the food name, DataFrame containing food items, and cosine similarity matrix as input. # Example: recommend_food_by_search(\"Pizza\", df, cosine_sim) And return the top 5 recommended food items.","title":"recommend_food_by_search"},{"location":"usage/","text":"Walkthrough Open the system in your browser by going to http://localhost:3000 . Click on the \"Get Started\" button to start using the system. 2.1. If you don't have a clear idea of what you want to eat, then enter your preferences, such as the type of food you like, any allergens you have, and your nutritional requirements. 2.2. Click on the \"Recommend\" button to get food recommendations based on your preferences. 2.3 The system will display a list of recommended food items along with detailed information about each food item. Now, If you have a clear idea of what you want to eat, then click on the \"Search\" icon and enter the name of the food item you are looking for. 3.1 This will open the search bar where you can enter the name of the food item you are looking for. 3.1. The system will display detailed information about the food item you searched for. Please note if there are no recommendations available based on your preferences, the system will display a message saying \"No recommendations found\". This was done due to the lack of data in the dataset. (2000 records only)","title":"Usage"},{"location":"usage/#walkthrough","text":"Open the system in your browser by going to http://localhost:3000 . Click on the \"Get Started\" button to start using the system. 2.1. If you don't have a clear idea of what you want to eat, then enter your preferences, such as the type of food you like, any allergens you have, and your nutritional requirements. 2.2. Click on the \"Recommend\" button to get food recommendations based on your preferences. 2.3 The system will display a list of recommended food items along with detailed information about each food item. Now, If you have a clear idea of what you want to eat, then click on the \"Search\" icon and enter the name of the food item you are looking for. 3.1 This will open the search bar where you can enter the name of the food item you are looking for. 3.1. The system will display detailed information about the food item you searched for. Please note if there are no recommendations available based on your preferences, the system will display a message saying \"No recommendations found\". This was done due to the lack of data in the dataset. (2000 records only)","title":"Walkthrough"},{"location":"working/","text":"How does Foodinator work? Foodinator is a simple web application that allows users to search for food items based on their preferences. Data Collection The data for Foodinator was collected from the Spoonacular API. The API provides a wide range of food items and their descriptions, ingredients, and nutritional information. In order to collect the data, we used the requests library in Python to make HTTP requests to the \"Get Recipe Information\" endpoint of the Spoonacular API. We then parsed the JSON response and extracted the relevant information such as the food item name, description, ingredients, and nutritional information. The data was collected in batches of 50 food items at a time, and we collected a total of 2000 food items for training the machine learning models. Data Processing Once we collected the data, we processed it to extract the relevant information and store it in a structured format. We used Python to process the data and store it in a CSV file for easy access. This is how the data is structured: Machine Learning Model(s) We trained 5 different machine learning models to predict the nutritional information of a food item based on its ingredients. The models we used are: K-Means Clustering Nearest Neighbors K-Nearest Neighbors Support Vector Machine Neural Network Each model was trained on a subset of the data and evaluated to ensure its accuracy. The silhouette score was used to evaluate the performance of the clustering models, while the accuracy score was used for the classification models and the neural network. Silhouette score is a measure of how similar an object is to its own cluster compared to other clusters. The score ranges from -1 to 1, where a higher value indicates better clustering. Accuracy score is the proportion of correct predictions made by the model. The silhouette score for the K-Means Clustering model was 0.014 and for the K-Nearest Neighbors model was 0.48 . The accuracy score for the Nearest Neighbors model was 0.945 , for the Support Vector Machine model was 0.68 , and for the Neural Network model was 0.72 . Based on these scores, we selected the K-Means Clustering model as the best model for giving recommendations to users based on their preferences. Machine Learning Model Description Silhouette Score Accuracy Score K-Means Clustering A clustering algorithm used to group similar food items based on their nutritional information. 0.014 N/A Nearest Neighbors A classification algorithm that predicts nutritional information based on the similarity of food items in the dataset. N/A 0.945 K-Nearest Neighbors A variation of the Nearest Neighbors algorithm that considers the K closest neighbors to predict nutritional information. 0.48 N/A Support Vector Machine A classification algorithm that separates food items into different classes based on their nutritional features. N/A 0.68 Neural Network A deep learning model used to predict nutritional information by learning patterns and relationships in the data. N/A 0.72 Model pipeline The model pipeline consists of the following steps: First we convert the food items into a vector representation using the TF-IDF vectorizer. Then we apply the K-Means Clustering model to cluster the food items based on their vector representations. Next, we filter the food items based on the ingredients provided by the user. Finally, we recommend the top 5 food items from the cluster that contains the most similar food items to the user's preferences. Database Based on the recommended food items, we extract the relevant information such as the food item description, image, ingredients, and instructions from the database and display it to the user. Recommendation System There are two main components of the recommendation system in Foodinator: The first recommendation system in Foodinator works by taking the user's input in the form of ingredients, Food type, allergies, and dietary restrictions. The system then uses the K-Means Clustering model to cluster the food items based on their vector representations. It then filters the food items based on the user's input and recommends the top 5 food items from the cluster that contains the most similar food items to the user's preferences. The second recommendation system in Foodinator works by taking the user's input in the form of a food item name. The system then uses the cosine similarity metric to find the most similar food items to the user's input and recommends the top 5 food items based on the similarity score. Web Application The web application is built using the FastAPI framework in Python. It consists of two main components: Home Page : The home page of the web application gives a brief overview of the application and their functionalities. Recommendation Page : The recommendation page allows users to input their preferences and get recommendations based on their input. Output Page : The output page displays the recommended food items to the user. For more information, please refer to the following sections of the documentation: - Modules - API Reference Flow Diagram","title":"Working"},{"location":"working/#how-does-foodinator-work","text":"Foodinator is a simple web application that allows users to search for food items based on their preferences.","title":"How does Foodinator work?"},{"location":"working/#data-collection","text":"The data for Foodinator was collected from the Spoonacular API. The API provides a wide range of food items and their descriptions, ingredients, and nutritional information. In order to collect the data, we used the requests library in Python to make HTTP requests to the \"Get Recipe Information\" endpoint of the Spoonacular API. We then parsed the JSON response and extracted the relevant information such as the food item name, description, ingredients, and nutritional information. The data was collected in batches of 50 food items at a time, and we collected a total of 2000 food items for training the machine learning models.","title":"Data Collection"},{"location":"working/#data-processing","text":"Once we collected the data, we processed it to extract the relevant information and store it in a structured format. We used Python to process the data and store it in a CSV file for easy access. This is how the data is structured:","title":"Data Processing"},{"location":"working/#machine-learning-models","text":"We trained 5 different machine learning models to predict the nutritional information of a food item based on its ingredients. The models we used are: K-Means Clustering Nearest Neighbors K-Nearest Neighbors Support Vector Machine Neural Network Each model was trained on a subset of the data and evaluated to ensure its accuracy. The silhouette score was used to evaluate the performance of the clustering models, while the accuracy score was used for the classification models and the neural network. Silhouette score is a measure of how similar an object is to its own cluster compared to other clusters. The score ranges from -1 to 1, where a higher value indicates better clustering. Accuracy score is the proportion of correct predictions made by the model. The silhouette score for the K-Means Clustering model was 0.014 and for the K-Nearest Neighbors model was 0.48 . The accuracy score for the Nearest Neighbors model was 0.945 , for the Support Vector Machine model was 0.68 , and for the Neural Network model was 0.72 . Based on these scores, we selected the K-Means Clustering model as the best model for giving recommendations to users based on their preferences. Machine Learning Model Description Silhouette Score Accuracy Score K-Means Clustering A clustering algorithm used to group similar food items based on their nutritional information. 0.014 N/A Nearest Neighbors A classification algorithm that predicts nutritional information based on the similarity of food items in the dataset. N/A 0.945 K-Nearest Neighbors A variation of the Nearest Neighbors algorithm that considers the K closest neighbors to predict nutritional information. 0.48 N/A Support Vector Machine A classification algorithm that separates food items into different classes based on their nutritional features. N/A 0.68 Neural Network A deep learning model used to predict nutritional information by learning patterns and relationships in the data. N/A 0.72","title":"Machine Learning Model(s)"},{"location":"working/#model-pipeline","text":"The model pipeline consists of the following steps: First we convert the food items into a vector representation using the TF-IDF vectorizer. Then we apply the K-Means Clustering model to cluster the food items based on their vector representations. Next, we filter the food items based on the ingredients provided by the user. Finally, we recommend the top 5 food items from the cluster that contains the most similar food items to the user's preferences.","title":"Model pipeline"},{"location":"working/#database","text":"Based on the recommended food items, we extract the relevant information such as the food item description, image, ingredients, and instructions from the database and display it to the user.","title":"Database"},{"location":"working/#recommendation-system","text":"There are two main components of the recommendation system in Foodinator: The first recommendation system in Foodinator works by taking the user's input in the form of ingredients, Food type, allergies, and dietary restrictions. The system then uses the K-Means Clustering model to cluster the food items based on their vector representations. It then filters the food items based on the user's input and recommends the top 5 food items from the cluster that contains the most similar food items to the user's preferences. The second recommendation system in Foodinator works by taking the user's input in the form of a food item name. The system then uses the cosine similarity metric to find the most similar food items to the user's input and recommends the top 5 food items based on the similarity score.","title":"Recommendation System"},{"location":"working/#web-application","text":"The web application is built using the FastAPI framework in Python. It consists of two main components: Home Page : The home page of the web application gives a brief overview of the application and their functionalities. Recommendation Page : The recommendation page allows users to input their preferences and get recommendations based on their input. Output Page : The output page displays the recommended food items to the user.","title":"Web Application"},{"location":"working/#for-more-information-please-refer-to-the-following-sections-of-the-documentation","text":"","title":"For more information, please refer to the following sections of the documentation:"},{"location":"working/#-modules","text":"","title":"- Modules"},{"location":"working/#-api-reference","text":"","title":"- API Reference"},{"location":"working/#flow-diagram","text":"","title":"Flow Diagram"}]}